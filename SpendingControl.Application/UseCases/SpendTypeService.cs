using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using SpendingControl.Application.Interfaces;
using SpendingControl.Domain.Entities;
using SpendingControl.Domain.Interfaces.Repositories;

namespace SpendingControl.Application.UseCases
{
    public class SpendTypeService : ISpendTypeService
    {
        private readonly ISpendTypeRepository _repo;

        public SpendTypeService(ISpendTypeRepository repo) => _repo = repo;

        public async Task<IEnumerable<SpendType>> GetByUserAsync(Guid userId)
        {
            if (userId == Guid.Empty) throw new ArgumentException("userId is required", nameof(userId));
            return await _repo.GetByUserAsync(userId);
        }

        public async Task<SpendType?> GetByIdAsync(int id) => await _repo.GetByIdAsync(id);

        public async Task<SpendType> CreateAsync(SpendType spendType)
        {
            if (spendType == null) throw new ArgumentNullException(nameof(spendType));
            if (spendType.UserId == Guid.Empty) throw new ArgumentException("UserId is required", nameof(spendType.UserId));

            spendType.Name = spendType.Name?.Trim();
            if (string.IsNullOrWhiteSpace(spendType.Name)) throw new ArgumentException("Name is required", nameof(spendType.Name));
            if (spendType.Name.Length > 200) throw new ArgumentException("Name too long", nameof(spendType.Name));

            // check duplicates
            var existing = await _repo.GetByUserAsync(spendType.UserId);
            if (existing.Any(s => s.Name.Equals(spendType.Name, StringComparison.OrdinalIgnoreCase)))
                throw new InvalidOperationException("A spend type with the same name already exists for this user.");

            // ensure code is generated by repository
            spendType.Code = 0;

            // domain validation requires Code > 0, so skip domain Validate here (repo will set code)
            return await _repo.AddAsync(spendType);
        }

        public async Task UpdateAsync(SpendType spendType, Guid userId)
        {
            if (spendType == null) throw new ArgumentNullException(nameof(spendType));
            if (userId == Guid.Empty) throw new ArgumentException("userId is required", nameof(userId));

            var current = await _repo.GetByIdAsync(spendType.Id) ?? throw new KeyNotFoundException("Spend type not found");
            if (current.UserId != userId) throw new UnauthorizedAccessException("You do not own this spend type");

            spendType.Name = spendType.Name?.Trim();
            if (string.IsNullOrWhiteSpace(spendType.Name)) throw new ArgumentException("Name is required", nameof(spendType.Name));
            if (spendType.Name.Length > 200) throw new ArgumentException("Name too long", nameof(spendType.Name));

            // check duplicates excluding current
            var existing = await _repo.GetByUserAsync(userId);
            if (existing.Any(s => s.Id != spendType.Id && s.Name.Equals(spendType.Name, StringComparison.OrdinalIgnoreCase)))
                throw new InvalidOperationException("A spend type with the same name already exists for this user.");

            // preserve code and user
            spendType.Code = current.Code;
            spendType.UserId = current.UserId;

            // call domain validate (now code > 0)
            spendType.Validate();

            await _repo.UpdateAsync(spendType);
        }

        public async Task DeleteAsync(int id, Guid userId)
        {
            if (userId == Guid.Empty) throw new ArgumentException("userId is required", nameof(userId));

            var current = await _repo.GetByIdAsync(id) ?? throw new KeyNotFoundException("Spend type not found");
            if (current.UserId != userId) throw new UnauthorizedAccessException("You do not own this spend type");

            await _repo.DeleteAsync(id);
        }
    }
}
